# <a href="https://docs.angularjs.org/guide/forms"> Angular </a>

## Hint
### 1. 避免直接操作dom元素    
>Custom directives to access the DOM: 
In AngularJS, the only place where an application should access the DOM is within directives. This is important because artifacts that access the DOM are hard to test. If you need to access the DOM directly you should write a custom directive for this. The directives guide explains how to do this.

### 2. 将不依赖于View的逻辑移入Service以便重用
>When the application grows it is a good practice to move view-independent logic from the controller into a service, so it can be reused by other parts of the application as well. 

### 3. 以数组的形式定义依赖可以保证angular即使minify之后也可以正常工作
>AngularJS uses this array syntax to define the dependencies so that the DI also works after minifying the code, which will most probably rename the argument name of the controller constructor function to something shorter like a.

### 4. Angularjs 标签中属性使用kebab-case，指令实现使用camelCase
>AngularJS uses kebab-case for its custom attributes and camelCase for the corresponding directives which implement them.

### 5. Angular 内置的service什么的都是以 $ 开头，如果是以 $$ 开头的话是内部私用的
> - The $ prefix is there to namespace AngularJS-provided services. To prevent collisions it's best to avoid naming your services and models anything that begins with a $.   
- If you inspect a Scope, you may also notice some properties that begin with $$. These properties are considered private, and should not be accessed or modified.

## HTML Compiler <a href="https://docs.angularjs.org/guide/compiler">Ref</a>

- Phase
	- Compile: 遍历整个dom树获取所有的directives，然后return  一个linking函数
	- Link: 将每一个directive与scope和model组合成一个live view
- Difference with 静态模板系统
 	- Consume DOM 而不是 String Templates
 	- Dom element bound to a model item will not change the lifetime of the binding.
- Directives Compile
	1. $complile 遍历整个dom，将所找到directive放入dom所对应directives list中。
	2. 当所有的directives 都被找到后，重排所有directive的优先级，并调用directive的compile方法返回link函数，在将所有的link方法组合成一个将会调用所有link方法的方法。
	3. $compile 通过调用组合Link方法将所有的template与对应的scope关联起来。
- Scope Isolating Issue
- Double Compilation

## Controller

### 1. Controller 使用禁忌
> - Use controllers to:
	- Set up the initial state of the $scope object.
	- Add behavior to the $scope object.
	- Do not use controllers to:
- Do not use controllers to:
	- Manipulate DOM — Controllers should contain only business logic. Putting any presentation logic into Controllers significantly affects its testability. AngularJS has databinding for most cases and directives to encapsulate manual DOM manipulation.
	- Format input — Use AngularJS form controls instead.
	- Filter output — Use AngularJS filters instead.
	- Share code or state across controllers — Use AngularJS services instead.
	- Manage the life-cycle of other components (for example, to create service instances). 

### 2. ng-controller 初始化
>When a Controller is attached to the DOM via the ng-controller directive, AngularJS will instantiate a new Controller object, using the specified Controller's constructor function. A new child scope will be created and made available as an injectable parameter to the Controller's constructor function as $scope.

### 3. Controller as con相当于将controller assign给$scope 的一个属性con
> If the controller has been attached using the controller as syntax then the controller instance will be assigned to a property on the new scope.

### 4. 子Controller可以访问父Controller的所有属性和方法
>It is common to attach Controllers at different levels of the DOM hierarchy. Since the ng-controller directive creates a new child scope, we get a hierarchy of scopes that inherit from each other. The $scope that each Controller receives will have access to properties and methods defined by Controllers higher up the hierarchy. See Understanding Scopes for more information about scope inheritance.      
Notice how we nested three ng-controller directives in our template. This will result in four scopes being created for our view.

## Services

### 1. 特点
> Lazily instantiated – AngularJS only instantiates a service when an application component depends on it.  
Singletons – Each component dependent on a service gets a reference to the single instance generated by the service factory.  
Like other core AngularJS identifiers, built-in services always start with $ (e.g. $http).

## Scope

### API
> Scopes provide APIs ($watch) to observe model mutations.   
Scopes provide APIs ($apply) to propagate any model changes through the system into the view from outside of the "AngularJS realm" (controllers, services, AngularJS event handlers).

### Root Scope
>Each AngularJS application has exactly one root scope, but may have any number of child scopes.
>The location where the root scope is attached to the DOM is defined by the location of ng-app directive.

### Scope Debugger
>The scope() function is only available when $compileProvider.debugInfoEnabled() is true (which is the default).   
To examine the scope in the debugger:   
- Right click on the element of interest in your browser and select 'inspect element'. You should see the browser debugger with the element you clicked on highlighted.   
- The debugger allows you to access the currently selected element in the console as $0 variable.   
- To retrieve the associated scope in console execute: angular.element($0).scope()

### Scope Propagation
> Scopes can propagate events in similar fashion to DOM events. The event can be broadcasted to the scope children or emitted to scope parents.   
本scope中触发的事件，无论哪种方式都可以保持触发.   

### Component 总是创建Isolate Scope
>Component directives are created with the .component() helper always create an isolate scope.

### $scope dirty check 三种策略
>- Watching by reference (scope.$watch (watchExpression, listener)) detects a change when the whole value returned by the watch expression switches to a new value. If the value is an array or an object, changes inside it are not detected. This is the most efficient strategy.   
- Watching collection contents (scope.$watchCollection (watchExpression, listener)) detects changes that occur inside an array or an object: When items are added, removed, or reordered. The detection is shallow - it does not reach into nested collections. Watching collection contents is more expensive than watching by reference, because copies of the collection contents need to be maintained. However, the strategy attempts to minimize the amount of copying required.   
- Watching by value (scope.$watch (watchExpression, listener, true)) detects any change in an arbitrarily nested data structure. It is the most powerful change detection strategy, but also the most expensive. A full traversal of the nested data structure is needed on each digest, and a full copy of it needs to be held in memory.

### 超出Angular执行上下文时可以通过调用 scope.$apply(stimulusFn)来显式进入
>Enter the AngularJS execution context by calling scope.$apply(stimulusFn), where stimulusFn is the work you wish to do in the AngularJS execution context.   
<a href="https://docs.angularjs.org/guide/scope">Integration with the browser event loop</a>

### Controller 可以访问对应的Scope，Service仅可以访问rootScope
>- Controllers are associated with an element in the DOM and so are provided with access to the scope. Other components (like services) only have access to the $rootScope service.   
- If a controller is instantiated as part of a route, then any values that are resolved as part of the route are made available for injection into the controller.

### Controller 依赖注入的三种方法
>- Using the inline array annotation (preferred)   
- Using the $inject property annotation   
- Implicitly from the function parameter names (has caveats)[可以通过添加ng-strict-di来禁止使用这种方式]

### Angular expression特点
>- Context: JavaScript expressions are evaluated against the global window. In AngularJS, expressions are evaluated against a scope object.   
- Forgiving: In JavaScript, trying to evaluate undefined properties generates ReferenceError or TypeError. In AngularJS, expression evaluation is forgiving to undefined and null.   
- Filters: You can use filters within expressions to format data before displaying it.   
- No Control Flow Statements: You cannot use the following in an AngularJS expression: conditionals, loops, or exceptions.   
- No Function Declarations: You cannot declare functions in an AngularJS expression, even inside ng-init directive.   
- No RegExp Creation With Literal Notation: You cannot create regular expressions in an AngularJS expression. An exception to this rule is ng-pattern which accepts valid RegExp.   
- No Object Creation With New Operator: You cannot use new operator in an AngularJS expression.   
- No Bitwise, Comma, And Void Operators: You cannot use Bitwise, , or void operators in an AngularJS expression.   
- If you want to run more complex JavaScript code, you should make it a controller method and call the method from your view. If you want to eval() an AngularJS expression yourself, use the $eval() method.

### 对于布尔值得插值表达式可以使用ng前缀
>For this reason, AngularJS provides special ng-prefixed directives for the following boolean attributes: disabled, required, selected, checked, readOnly , and open.

### 有些属性非常挑剔，需要使用ng-attr作为前缀
> - With ng-attr-cx you can work around this problem.
- If one wants to modify a camelcased attribute (SVG elements have valid camelcased attributes), such as viewBox on the svg element, one can use underscores to denote that the attribute to bind to is naturally camelcased.
- size in "select" elements (see issue 1619)   
- placeholder in "textarea" in Internet Explorer 10/11 (see issue 5025)   
- type in "button" in Internet Explorer 11 (see issue 14117)   
- value in "progress" in Internet Explorer = 11 (see issue 7218) 

### Filter大部分情况下在输入值改变的情况下更新，除了以下情况
>- In general, this applies only to filters that take primitive values as inputs. Filters that receive Objects as input are executed on each $digest, as it would be too costly to track if the inputs have changed.   
- Filters that are marked as $stateful are also executed on each $digest. See Stateful filters for more information. Note that no AngularJS core filters are $stateful.

### 元素directive标签和属性推荐格式
> Best Practice: Prefer using the dash-delimited format (e.g. ng-bind for ngBind). If you want to use an HTML validating tool, you can instead use the data-prefixed version (e.g. data-ng-bind for ngBind). The other forms shown above are accepted for legacy reasons but we advise you to avoid them.

### 注册在Scope上的事件会自动delete，其它的需要手动clean up
>Listeners registered to scopes and elements are automatically cleaned up when they are destroyed, but if you registered a listener on a service, or registered a listener on a DOM node that isn't being deleted, you'll have to clean it up yourself or you risk introducing a memory leak.